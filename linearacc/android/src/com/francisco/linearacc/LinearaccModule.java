/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2018 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package com.francisco.linearacc;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.KrollProxy;
import org.appcelerator.kroll.KrollRuntime;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.titanium.util.TiSensorHelper;

import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;


@Kroll.module(name="Linearacc", id="com.francisco.linearacc")
public class LinearaccModule extends KrollModule implements SensorEventListener
{

	private static final String EVENT_UPDATE = "update";

	// Used by TYPE_ACCELEROMETER
	private boolean accelerometerRegistered = false;
	private long lastSensorEventTimestamp = 0;

	private float[] accellerometerValues = null;
	float[] gravity = new float[3];


	public LinearaccModule()
	{
		super();

		// Set up a listener to be invoked when the JavaScript runtime is about to be terminated/disposed.
		KrollRuntime.addOnDisposingListener(new KrollRuntime.OnDisposingListener() {
			@Override
			public void onDisposing(KrollRuntime runtime)
			{
				// Remove this listener from the runtime's static collection.
				KrollRuntime.removeOnDisposingListener(this);

				// Unregister the sensor listener.
				if (accelerometerRegistered) {
					TiSensorHelper.unregisterListener(Sensor.TYPE_ACCELEROMETER, LinearaccModule.this);
					accelerometerRegistered = false;
				}
			}
		});
	}

	@Override
	public void eventListenerAdded(String type, int count, final KrollProxy proxy)
	{
		if (!accelerometerRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.registerListener(Sensor.TYPE_ACCELEROMETER, this, SensorManager.SENSOR_DELAY_UI);
				accelerometerRegistered = true;
			}
		super.eventListenerAdded(type, count, proxy);
		}
	}

	@Override
	public void eventListenerRemoved(String type, int count, KrollProxy proxy)
	{
		if (accelerometerRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_ACCELEROMETER, this);
				accelerometerRegistered = false;
			}
		super.eventListenerRemoved(type, count, proxy);
		}

	}

	public void onAccuracyChanged(Sensor sensor, int accuracy)
	{
	}

	@SuppressWarnings("deprecation") 
	public void onSensorChanged(SensorEvent event)
	{

		if (event.timestamp - lastSensorEventTimestamp > 100) {
			lastSensorEventTimestamp = event.timestamp;

			accellerometerValues = event.values.clone();
			
			float[] linear_acceleration = new float[3];
			final float alpha = (float) 0.8;

			//float x = event.values[SensorManager.DATA_X];
			//float y = event.values[SensorManager.DATA_Y];
			//float z = event.values[SensorManager.DATA_Z];
			
			float x = accellerometerValues[0];
			float y = accellerometerValues[1];
			float z = accellerometerValues[2];

			gravity[0] = alpha * gravity[0] + (1 - alpha) * x;
			gravity[1] = alpha * gravity[1] + (1 - alpha) * y;
			gravity[2] = alpha * gravity[2] + (1 - alpha) * z;

			linear_acceleration[0] = x - gravity[0];
			linear_acceleration[1] = y - gravity[1];
			linear_acceleration[2] = z - gravity[2];
			

			KrollDict data = new KrollDict();
			data.put("type", EVENT_UPDATE);
			data.put("timestamp", lastSensorEventTimestamp);
			data.put("x", x);
			data.put("y", y);
			data.put("z", z);
			data.put("linearAccelerationX", linear_acceleration[0]);
			data.put("linearAccelerationY", linear_acceleration[1]);
			data.put("linearAccelerationZ", linear_acceleration[2]);

			fireEvent(EVENT_UPDATE, data);
		}
	}


	@Override
	public String getApiName()
	{
		return "Francisco.LinearaccModule";
	}

	/**
	* Francisco's linear acc
	*
	*/

}

